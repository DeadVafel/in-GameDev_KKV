# РАЗРАБОТКА СИСТЕМЫ МАШИННОГО ОБУЧЕНИЯ.
Отчет по лабораторной работе #3 выполнил:
- Колчанов Константин Викторович
- РИ-110949
Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | # | 20 |


## Цель работы
познакомиться с программными средствами для создания системы машинного обучения и ее интеграции в Unity.

## Задание 1
### Реализовать совместную работу и передачу данных в связке Python - Google-Sheets – Unity.

1.Создан новый проект.
![Unity](![image](https://user-images.githubusercontent.com/104380312/198032067-e006226f-39f3-405c-8c08-c7384d925542.png))
2. Последовательно добавлены .json – файлы.
![.json](![image](https://user-images.githubusercontent.com/104380312/198032194-8391fb94-7082-496e-b9e6-dc73e641a0ef.png))
3.Написана серия команд для создания и активации нового ML-агента, а также для скачивания необходимых библиотек.
![console](![image](https://user-images.githubusercontent.com/104380312/198032455-9edc5f81-46c3-44cb-957d-fd86db9b6d69.png))
![console](![image](https://user-images.githubusercontent.com/104380312/198032550-29b6055c-55bc-4e75-b45c-7c044553463d.png))
![console](![image](https://user-images.githubusercontent.com/104380312/198032595-d377334c-724c-4f91-9b31-c6a19ce5ab05.png))
5.Создание на сцене плоскости, куба и сферы, а также настройка павраметров.
![console](![image](https://user-images.githubusercontent.com/104380312/198033341-0a5a2c61-3500-4494-8f52-6a0fb3691e92.png))
6.В корень проекта добавьте файл конфигурации нейронной сети.
![console](![image](https://user-images.githubusercontent.com/104380312/198033414-376bea7b-8182-478a-aabf-a8212b1e9b02.png))
7.запустите сцену, проверьте работу ML-Agent’a.
![console](![image](https://user-images.githubusercontent.com/104380312/198033450-f15cec35-64c7-4326-894a-5ba3bc1eec5b.png))
8.Сделайте 3, 9, 27 копий модели «Плоскость-Сфера-Куб».
![console](![image](https://user-images.githubusercontent.com/104380312/198033531-56575652-a634-45e1-92e6-19bedc9f84c4.png))
9.Сделайте вывод.
За меньшее время достигаются более точные показатели во время обучения ИИ.

## Задание 2
### Подробно опишите каждую строку файла конфигурации нейронной сети. Самостоятельно найдите информацию о компонентах Decision Requester, Behavior Parameters, добавленных сфере. 

trainer_type: ppo - Тип обучения с поощрением

batch_size - Количество опытов на каждой итерации градиентного спуска. Это всегда должно быть в несколько раз меньше, чем buffer_size. Если вы используете непрерывное пространство действий, это значение должно быть большим (порядка 1000). Если вы используете дискретное пространство действий, это значение должно быть меньше (порядка 10 секунд).
 
buffer_size - Количество опыта, который необходимо собрать перед обновлением модели политики. Соответствует тому, сколько опыта должно быть собрано, прежде чем мы приступим к какому-либо изучению или обновлению модели. Это должно быть в несколько раз больше, чем batch_size. Обычно больший размер буфера соответствует более стабильным обновлениям обучения.
 
learning_rate - Начальная скорость обучения для градиентного спуска. Соответствует силе каждого шага обновления градиентного спуска. Обычно это значение следует уменьшить, если тренировка нестабильна, а вознаграждение не увеличивается последовательно.
 
beta - Сила регуляризации энтропии, которая делает политику "более случайной". Это гарантирует, что агенты должным образом исследуют пространство действий во время обучения. Увеличение этого значения обеспечит выполнение большего количества случайных действий. Это должно быть скорректировано таким образом, чтобы энтропия  медленно уменьшалась вместе с увеличением вознаграждения. Если энтропия падает слишком быстро, нужно увеличить бета-версию. Если энтропия падает слишком медленно, уменьшить бета.
  
epsilon - 
Влияет на то, насколько быстро политика может развиваться во время обучения. Соответствует допустимому порогу расхождения между старой и новой политиками при обновлении с градиентным спуском. Установка этого значения небольшим приведет к более стабильным обновлениям, но также замедлит процесс обучения.
  
lambd - Параметр регуляризации (лямбда), используемый при расчете Обобщенной оценки преимущества (GAE). Это можно рассматривать как то, насколько агент полагается на свою текущую оценку стоимости при расчете обновленной оценки стоимости. Низкие значения соответствуют большей зависимости от текущей оценки ценности (что может быть большой погрешностью), а высокие значения соответствуют большей зависимости от фактических вознаграждений, полученных в окружающей среде (что может быть высокой дисперсией). Параметр обеспечивает компромисс между ними, и правильное значение может привести к более стабильному процессу обучения.
  
num_epoch - Количество проходов, которые необходимо выполнить через буфер опыта при выполнении оптимизации градиентного спуска.Чем больше размер пакета, тем больше это допустимо сделать. Уменьшение этого параметра обеспечит более стабильные обновления за счет более медленного обучения.

learning_rate_schedule - Определяет, как скорость обучения меняется с течением времени. 

normalize - Применяется ли нормализация к входным данным векторного наблюдения. Эта нормализация основана на текущем среднем значении и дисперсии векторного наблюдения. Нормализация может быть полезна в случаях со сложными задачами непрерывного управления, но может быть вредна при более простых задачах дискретного управления.

hidden_units - Количество единиц в скрытых слоях нейронной сети. Соответствует количеству единиц в каждом полностью подключенном слое нейронной сети. Для простых задач, где правильным действием является простая комбинация входных данных наблюдения, это должно быть небольшим. Для задач, где действие представляет собой очень сложное взаимодействие между переменными наблюдения, это должно быть больше.
  
num_layers - Количество скрытых слоев в нейронной сети. Соответствует количеству скрытых слоев, присутствующих после ввода наблюдения или после кодирования CNN визуального наблюдения. Для простых задач меньшее количество слоев, скорее всего, будет обучаться быстрее и эффективнее. Для более сложных задач управления может потребоваться больше уровней.
  
gamma - Коэффициент дисконтирования для будущих вознаграждений, поступающих от окружающей среды. Это можно рассматривать как то, насколько далеко в будущем агент должен заботиться о возможных вознаграждениях. В ситуациях, когда агент должен действовать в настоящем, чтобы подготовиться к вознаграждению в отдаленном будущем, это значение должно быть большим. В тех случаях, когда вознаграждение более немедленное, оно может быть меньше. Должно быть строго меньше 1.
  
strength - Фактор, на который можно умножить вознаграждение, получаемое от окружающей среды. Типичные диапазоны будут варьироваться в зависимости от сигнала вознаграждения.

max_steps - максимальное количество проходов

time_horizon - временные рамки 

summary_freq - суммированная частота 

Decision Requester - запрос на принятие решения вызывает CollectObservation, а затем получает последнее действие в OnActionReceived, основанное на этом новом собранном наблюдении. С действиями из TakeActionBetweenDecisions он только снова вызовет OnActionReceived без сбора новых наблюдений и выведет последнее действие, которое он получил от NN.

Behavior Parameters - Параметры поведения — У каждого Агента должно быть определенное поведение. Поведение определяет, как Агент принимает решения. Максимальный шаг — Определяет, сколько шагов моделирования может произойти до окончания эпизода Агента.

## Задание 3
### Доработайте сцену и обучите ML-Agent таким образом, чтобы шар перемещался между двумя кубами разного цвета.


## Выводы
Игровой баланс — в играх субъективное «равновесие» между персонажами, командами, тактиками игры и другими игровыми объектами.Для создания качественного игрового процесса гейм-дизайнеры обычно настраивают баланс игры итеративно:
1.Выполняют нагрузочный тест тысячами плейтестинговых сессий, в которых участвуют тестеры
2.Учитывают их отзывы и изменяют дизайн игры
3.Повторяют этапы 1 и 2, пока результатом не будут довольны и тестеры, и гейм-дизайнеры
Этот процесс не только занимает много времени, но и неидеален — чем сложнее игра, тем проще незначительным недосмотрам привести к дисбалансу. Когда в играх есть множество различных ролей с десятками взаимосвязанных навыков, всё это сильно усложняет нахождение нужного баланса. При ипользовании системы машинного обучения время сокращается, а также приводит к более точным, проверенным и необходимым показателям.
